#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// --- CONSTANTES E DEFINI√á√ïES ---
#define FILA_SIZE 5    // Capacidade fixa da fila de pe√ßas futuras
#define PILHA_SIZE 3   // Capacidade limitada da pilha de reserva
#define TROCA_MULTIPLA 3 // N√∫mero de pe√ßas para a troca m√∫ltipla

// --- ESTRUTURA DE DADOS ---

/**
 * @brief Estrutura que representa uma Pe√ßa do Tetris (Item b√°sico).
 */
typedef struct {
    char nome;          // Tipo da pe√ßa ('I', 'O', 'T', 'L', etc.)
    int id;             // Identificador √∫nico da pe√ßa
} Peca;

/**
 * @brief Estrutura que representa a Fila Circular de Pe√ßas.
 */
typedef struct {
    Peca pecas[FILA_SIZE];
    int frente;
    int traseira;
    int count;
} FilaPecas;

/**
 * @brief Estrutura que representa a Pilha de Pe√ßas Reservadas (LIFO).
 */
typedef struct {
    Peca pecas[PILHA_SIZE];
    int topo; // √çndice da √∫ltima pe√ßa inserida
} PilhaPecas;

// --- VARI√ÅVEIS GLOBAIS ---
FilaPecas fila;
PilhaPecas pilha;
int proximo_id_global = 0; // Contador global para IDs √∫nicos

// -------------------------------------------------------------------
//                        FUN√á√ïES DE GERA√á√ÉO E UTILIDADE
// -------------------------------------------------------------------

/**
 * @brief Gera uma nova pe√ßa com um tipo aleat√≥rio e um ID √∫nico.
 * @return A nova pe√ßa gerada.
 */
Peca gerarPeca() {
    Peca novaPeca;
    char tipos[] = {'I', 'O', 'T', 'L', 'J', 'S', 'Z'};
    int indice_aleatorio = rand() % (sizeof(tipos) / sizeof(tipos[0]));
    
    novaPeca.nome = tipos[indice_aleatorio];
    novaPeca.id = proximo_id_global++; // Atribui o ID atual e incrementa
    
    return novaPeca;
}

/**
 * @brief Inicializa a Fila e a Pilha.
 */
void inicializarEstruturas() {
    // Inicializa√ß√£o da Fila Circular
    fila.frente = 0;
    fila.traseira = -1;
    fila.count = 0;

    // Inicializa√ß√£o da Pilha
    pilha.topo = -1; 
    
    srand(time(NULL));
    printf("‚úÖ Estruturas inicializadas. Fila de Pe√ßas (Capacidade %d) e Pilha de Reserva (Capacidade %d).\n", FILA_SIZE, PILHA_SIZE);
}

// -------------------------------------------------------------------
//                          FUN√á√ïES DE PILHA
// -------------------------------------------------------------------

int isPilhaFull() {
    return pilha.topo == PILHA_SIZE - 1;
}

int isPilhaEmpty() {
    return pilha.topo == -1;
}

/**
 * @brief Insere uma pe√ßa no topo da pilha (PUSH).
 * @param peca A pe√ßa a ser inserida.
 */
void push(Peca peca) {
    if (isPilhaFull()) return;
    pilha.pecas[++pilha.topo] = peca;
}

/**
 * @brief Remove e retorna a pe√ßa do topo da pilha (POP).
 * @return A pe√ßa removida ou uma pe√ßa nula se a pilha estiver vazia.
 */
Peca pop() {
    Peca nula = {'\0', -1};
    if (isPilhaEmpty()) return nula;
    return pilha.pecas[pilha.topo--];
}

/**
 * @brief Retorna a pe√ßa do topo da pilha sem remov√™-la (PEEK).
 * @return A pe√ßa do topo ou uma pe√ßa nula.
 */
Peca peekPilha() {
    Peca nula = {'\0', -1};
    if (isPilhaEmpty()) return nula;
    return pilha.pecas[pilha.topo];
}

// -------------------------------------------------------------------
//                          FUN√á√ïES DE FILA
// -------------------------------------------------------------------

int isFilaFull() {
    return fila.count == FILA_SIZE;
}

int isFilaEmpty() {
    return fila.count == 0;
}

/**
 * @brief Insere uma pe√ßa no final da fila (ENQUEUE), usando l√≥gica circular.
 * @param peca A pe√ßa a ser inserida.
 */
void enqueue(Peca peca) {
    if (isFilaFull()) {
        // No Tetris Stack, a fila deve estar sempre cheia ou quase cheia.
        printf("‚ö†Ô∏è Tentativa de Enqueue falhou: Fila cheia. (N√£o deveria ocorrer na mec√¢nica do jogo)\n");
        return;
    }
    fila.traseira = (fila.traseira + 1) % FILA_SIZE;
    fila.pecas[fila.traseira] = peca;
    fila.count++;
}

/**
 * @brief Remove e retorna a pe√ßa da frente da fila (DEQUEUE).
 * @return A pe√ßa removida ou uma pe√ßa nula.
 */
Peca dequeue() {
    Peca nula = {'\0', -1};
    if (isFilaEmpty()) return nula;

    Peca pecaRemovida = fila.pecas[fila.frente];
    fila.frente = (fila.frente + 1) % FILA_SIZE;
    fila.count--;
    return pecaRemovida;
}

/**
 * @brief Retorna a pe√ßa da frente da fila sem remov√™-la (PEEK).
 * @return A pe√ßa da frente ou uma pe√ßa nula.
 */
Peca peekFila() {
    Peca nula = {'\0', -1};
    if (isFilaEmpty()) return nula;
    return fila.pecas[fila.frente];
}

/**
 * @brief Mant√©m a fila cheia, inserindo uma nova pe√ßa gerada.
 */
void reabastecerFila() {
    if (fila.count < FILA_SIZE) {
        enqueue(gerarPeca());
    }
}

// -------------------------------------------------------------------
//                      MEC√ÇNICAS AVAN√áADAS DO JOGO
// -------------------------------------------------------------------

/**
 * @brief 1. Simula "jogar" a pe√ßa da frente da fila.
 */
void acaoJogarPeca() {
    Peca jogada = dequeue();
    if (jogada.id != -1) {
        printf("\nüî• PE√áA JOGADA: Tipo '%c', ID %d. Fila se move.\n", jogada.nome, jogada.id);
        reabastecerFila(); // Nova pe√ßa √© adicionada ao final da fila
    } else {
        printf("\nüö´ ERRO: Fila est√° vazia, imposs√≠vel jogar.\n");
    }
}

/**
 * @brief 2. Move a pe√ßa da frente da fila para o topo da pilha (RESERVAR).
 */
void acaoReservarPeca() {
    if (isPilhaFull()) {
        printf("\nüö´ ERRO: Pilha de reserva cheia (M√°x. %d). Use a pe√ßa reservada primeiro.\n", PILHA_SIZE);
        return;
    }
    
    Peca reservada = dequeue();
    if (reservada.id != -1) {
        push(reservada);
        printf("\nüîÅ PE√áA RESERVADA: Tipo '%c', ID %d. Movida da Fila para Pilha.\n", reservada.nome, reservada.id);
        reabastecerFila(); // Nova pe√ßa √© adicionada ao final da fila
    } else {
        printf("\nüö´ ERRO: Fila est√° vazia, imposs√≠vel reservar.\n");
    }
}

/**
 * @brief 3. Remove a pe√ßa do topo da pilha, simulando seu uso.
 */
void acaoUsarPecaReservada() {
    Peca usada = pop();
    if (usada.id != -1) {
        printf("\nüíé PE√áA USADA: Tipo '%c', ID %d. Removida do topo da Pilha.\n", usada.nome, usada.id);
        // A√ß√£o na pilha n√£o reabastece a fila, pois a pe√ßa usada n√£o √© da fila.
    } else {
        printf("\nüö´ ERRO: Pilha de reserva est√° vazia, imposs√≠vel usar.\n");
    }
}

/**
 * @brief 4. Troca a pe√ßa da frente da fila com o topo da pilha.
 */
void acaoTrocarPecaAtual() {
    if (isFilaEmpty() || isPilhaEmpty()) {
        printf("\nüö´ ERRO: Troca falhou. Fila ou Pilha est√£o vazias.\n");
        return;
    }

    // Pega as pe√ßas para troca sem remov√™-las (peek)
    Peca pecaFila = peekFila(); // A pe√ßa da frente da fila (√≠ndice: fila.frente)
    Peca pecaPilha = peekPilha(); // A pe√ßa do topo da pilha (√≠ndice: pilha.topo)
    
    // 1. Remove logicamente da fila (mantendo o valor)
    fila.frente = (fila.frente + 1) % FILA_SIZE;
    fila.count--;
    
    // 2. Remove logicamente da pilha (mantendo o valor)
    pilha.topo--;

    // 3. Insere a pe√ßa da Pilha no lugar da Frente da Fila
    fila.traseira = (fila.frente - 1 + FILA_SIZE) % FILA_SIZE;
    fila.pecas[fila.traseira] = pecaPilha;
    fila.frente = fila.traseira;
    fila.count++;
    
    // 4. Insere a pe√ßa da Fila no lugar do Topo da Pilha
    pilha.pecas[++pilha.topo] = pecaFila;

    printf("\nüîÑ TROCA R√ÅPIDA: A pe√ßa da Fila ('%c', ID %d) e Pilha ('%c', ID %d) foram trocadas.\n", 
           pecaFila.nome, pecaFila.id, pecaPilha.nome, pecaPilha.id);
    
    // N√£o reabastece a fila pois n√£o houve perda l√≠quida de pe√ßas.
}

/**
 * @brief 5. Troca os 3 primeiros da fila com as 3 pe√ßas da pilha.
 */
void acaoTrocaMultipla() {
    if (fila.count < TROCA_MULTIPLA || pilha.topo < TROCA_MULTIPLA - 1) {
        printf("\nüö´ ERRO: Troca M√∫ltipla falhou. S√£o necess√°rios %d pe√ßas em ambas as estruturas.\n", TROCA_MULTIPLA);
        return;
    }

    Peca tempFila[TROCA_MULTIPLA];
    Peca tempPilha[TROCA_MULTIPLA];
    
    // 1. Copia os N primeiros da FILA
    int fila_idx = fila.frente;
    for (int i = 0; i < TROCA_MULTIPLA; i++) {
        tempFila[i] = fila.pecas[fila_idx];
        fila_idx = (fila_idx + 1) % FILA_SIZE;
    }

    // 2. Copia os N primeiros da PILHA (do topo para base)
    for (int i = 0; i < TROCA_MULTIPLA; i++) {
        tempPilha[i] = pilha.pecas[pilha.topo - i];
    }
    
    // 3. Sobrescreve a FILA com as pe√ßas da PILHA
    fila_idx = fila.frente;
    for (int i = 0; i < TROCA_MULTIPLA; i++) {
        fila.pecas[fila_idx] = tempPilha[i];
        fila_idx = (fila_idx + 1) % FILA_SIZE;
    }

    // 4. Sobrescreve a PILHA com as pe√ßas da FILA (na ordem reversa, LIFO)
    for (int i = 0; i < TROCA_MULTIPLA; i++) {
        pilha.pecas[pilha.topo - i] = tempFila[i];
    }

    printf("\nüîÅüîÅ TROCA M√öLTIPLA REALIZADA: %d pe√ßas trocadas entre Fila e Pilha.\n", TROCA_MULTIPLA);
}


// -------------------------------------------------------------------
//                             EXIBI√á√ÉO DE ESTADO
// -------------------------------------------------------------------

/**
 * @brief Exibe o estado atual da Fila.
 */
void exibirFila() {
    printf("Fila de pe√ßas (%d/%d): ", fila.count, FILA_SIZE);

    if (isFilaEmpty()) {
        printf("(Vazia)\n");
        return;
    }

    int i = fila.frente;
    for (int j = 0; j < fila.count; j++) {
        printf("[%c %d]", fila.pecas[i].nome, fila.pecas[i].id);
        if (j < fila.count - 1) {
            printf(" -> ");
        }
        i = (i + 1) % FILA_SIZE;
    }
    printf("\n");
}

/**
 * @brief Exibe o estado atual da Pilha (Topo -> Base).
 */
void exibirPilha() {
    printf("Pilha de reserva (Topo -> Base) (%d/%d): ", pilha.topo + 1, PILHA_SIZE);

    if (isPilhaEmpty()) {
        printf("(Vazia)\n");
        return;
    }

    for (int i = pilha.topo; i >= 0; i--) {
        printf("[%c %d]", pilha.pecas[i].nome, pilha.pecas[i].id);
        if (i > 0) {
            printf(" -> ");
        }
    }
    printf("\n");
}

/**
 * @brief Exibe o estado completo da simula√ß√£o.
 */
void exibirEstado() {
    printf("\n\n--- ESTADO ATUAL DO JOGO ---\n");
    exibirFila();
    exibirPilha();
    printf("---------------------------\n");
}


// -------------------------------------------------------------------
//                        FUN√á√ÉO PRINCIPAL E MENU
// -------------------------------------------------------------------

void exibirMenu() {
    printf("\n==================================\n");
    printf("üëæ Tetris Stack: Controle AVAN√áADO\n");
    printf("==================================\n");
    printf("C√≥digo | A√ß√£o\n");
    printf("----------------------------------\n");
    printf("  1    | Jogar pe√ßa da frente da fila\n");
    printf("  2    | Reservar pe√ßa (Fila -> Pilha)\n");
    printf("  3    | Usar pe√ßa reservada (Pop Pilha)\n");
    printf("  4    | Trocar pe√ßa da frente da fila com o topo da pilha\n");
    printf("  5    | Trocar os %d primeiros da fila com as %d pe√ßas da pilha\n", TROCA_MULTIPLA, TROCA_MULTIPLA);
    printf("  0    | Sair\n");
    printf("----------------------------------\n");
    printf("Escolha uma op√ß√£o: ");
}

int main() {
    int opcao;

    inicializarEstruturas();
    
    // 1. Pr√©-popula a fila para o tamanho m√°ximo
    printf("‚öôÔ∏è Pr√©-populando a fila...\n");
    while (!isFilaFull()) {
        enqueue(gerarPeca());
    }
    
    // 2. Pr√©-popula a pilha para a troca m√∫ltipla
    // Remove 3 da fila e coloca na pilha, depois reabastece a fila.
    for (int i = 0; i < PILHA_SIZE; i++) {
        push(dequeue());
    }
    reabastecerFila();
    reabastecerFila();
    reabastecerFila(); // Garante que a fila volte a ficar cheia (FILA_SIZE)

    do {
        exibirEstado();
        exibirMenu();
        
        if (scanf("%d", &opcao) != 1) {
            printf("\nOp√ß√£o inv√°lida. Digite um n√∫mero.\n");
            int c; while ((c = getchar()) != '\n' && c != EOF); 
            continue;
        }

        switch (opcao) {
            case 1: acaoJogarPeca(); break;
            case 2: acaoReservarPeca(); break;
            case 3: acaoUsarPecaReservada(); break;
            case 4: acaoTrocarPecaAtual(); break;
            case 5: acaoTrocaMultipla(); break;
            case 0: printf("\nüëã Saindo do Tetris Stack. At√© a pr√≥xima rodada!\n"); break;
            default: printf("\nOp√ß√£o desconhecida! Tente novamente.\n");
        }
        
        if (opcao != 0) {
            printf("\nPressione ENTER para continuar...");
            int c; while ((c = getchar()) != '\n' && c != EOF); 
            getchar();
        }

    } while (opcao != 0);

    return 0;
}